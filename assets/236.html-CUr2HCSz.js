import{_ as e,c as p,a as s,e as l,d as o,b as c,r as t,o as i}from"./app-DOK2Wtno.js";const d={},r={href:"https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/",target:"_blank",rel:"noopener noreferrer"};function u(k,n){const a=t("ExternalLinkIcon");return i(),p("div",null,[s("blockquote",null,[s("p",null,[s("a",r,[n[0]||(n[0]=o("二叉树的最近公共祖先")),c(a)])])]),n[1]||(n[1]=l(`<h2 id="题目描述" tabindex="-1"><a class="header-anchor" href="#题目描述"><span>题目描述</span></a></h2><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p><strong>示例</strong></p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre class="language-text"><code><span class="line">输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1</span>
<span class="line">输出：3</span>
<span class="line"></span>
<span class="line">输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4</span>
<span class="line">输出：5</span>
<span class="line"></span>
<span class="line">输入：root = [1,2], p = 1, q = 2</span>
<span class="line">输出：1</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="解答" tabindex="-1"><a class="header-anchor" href="#解答"><span>解答</span></a></h2><h3 id="dfs-深度优先搜索" tabindex="-1"><a class="header-anchor" href="#dfs-深度优先搜索"><span>DFS（深度优先搜索）</span></a></h3><h4 id="关键思路" tabindex="-1"><a class="header-anchor" href="#关键思路"><span>关键思路</span></a></h4><p>对于根节点 <code>root</code>，<code>p</code> 和 <code>q</code> 的分布有两种可能：</p><ul><li><code>p</code> 和 <code>q</code> 分居 <code>root</code> 的左右子树，则 LCA 为 <code>root</code></li><li><code>p</code> 和 <code>q</code> 存在于 <code>root</code> 的同一侧子树中，就变成规模小一点的相同问题</li></ul><h4 id="具体步骤" tabindex="-1"><a class="header-anchor" href="#具体步骤"><span>具体步骤</span></a></h4><p>定义递归函数</p><p>递归函数：返回<strong>当前子树</strong>中 <code>p</code> 和 <code>q</code> 的 LCA。如果没有 LCA，就返回 null</p><p>从根节点 root 开始往下递归遍历：</p><ul><li>如果遍历到 <code>p</code> 或 <code>q</code>，比方说 <code>p</code>，则 LCA 要么是当前的 <code>p</code>（<code>q</code> 在 <code>p</code> 的子树中），要么是 <code>p</code> 之上的节点（<code>q</code> 不在 <code>p</code> 的子树中），不可能是 <code>p</code> 之下的节点，不用继续往下走，返回当前的 <code>p</code></li><li>当遍历到 <code>null</code> 节点，空树不存在 <code>p</code> 和 <code>q</code>，没有 LCA，返回 null</li><li>当遍历的节点 <code>root</code> 不是 <code>p</code> 或 <code>q</code> 或 <code>null</code>，则递归搜寻 <code>root</code> 的左右子树 <ul><li>如果左右子树的递归都有结果，说明 <code>p</code> 和 <code>q</code> 分居 <code>root</code> 的左右子树，返回 <code>root</code></li><li>如果只是一个子树递归调用有结果，说明 <code>p</code> 和 <code>q</code> 都在这个子树，返回该子树递归结果</li><li>如果两个子树递归结果都为 <code>null</code>，说明 <code>p</code> 和 <code>q</code> 都不在这两个子树中，返回 <code>null</code></li></ul></li></ul><details class="custom-container details"><summary class="custom-container-title">Code</summary><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="line"><span class="token doc-comment comment">/**</span>
<span class="line"> * Definition for a binary tree node.</span>
<span class="line"> * function TreeNode(val) <span class="token punctuation">{</span></span>
<span class="line"> *     this.val = val;</span>
<span class="line"> *     this.left = this.right = null;</span>
<span class="line"> * <span class="token punctuation">}</span></span>
<span class="line"> */</span></span>
<span class="line"><span class="token doc-comment comment">/**</span>
<span class="line"> * <span class="token keyword">@param</span> <span class="token class-name"><span class="token punctuation">{</span>TreeNode<span class="token punctuation">}</span></span> <span class="token parameter">root</span></span>
<span class="line"> * <span class="token keyword">@param</span> <span class="token class-name"><span class="token punctuation">{</span>TreeNode<span class="token punctuation">}</span></span> <span class="token parameter">p</span></span>
<span class="line"> * <span class="token keyword">@param</span> <span class="token class-name"><span class="token punctuation">{</span>TreeNode<span class="token punctuation">}</span></span> <span class="token parameter">q</span></span>
<span class="line"> * <span class="token keyword">@return</span> <span class="token class-name"><span class="token punctuation">{</span>TreeNode<span class="token punctuation">}</span></span></span>
<span class="line"> */</span></span>
<span class="line"><span class="token keyword">var</span> <span class="token function-variable function">lowestCommonAncestor</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">const</span> <span class="token function-variable function">dfs</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">node</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// 如果当前节点为空，返回 null</span></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token comment">// 如果当前节点是 p 或 q，返回当前节点</span></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">===</span> p <span class="token operator">||</span> node <span class="token operator">===</span> q<span class="token punctuation">)</span> <span class="token keyword">return</span> node<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">const</span> left <span class="token operator">=</span> <span class="token function">dfs</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">const</span> right <span class="token operator">=</span> <span class="token function">dfs</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token comment">// 如果左右子树都找到了 p 或 q，说明当前节点是 LCA</span></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&amp;&amp;</span> right<span class="token punctuation">)</span> <span class="token keyword">return</span> node<span class="token punctuation">;</span></span>
<span class="line">    <span class="token comment">// 如果只在左子树中找到 p 或 q，返回左子树的结果</span></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span>left<span class="token punctuation">)</span> <span class="token keyword">return</span> left<span class="token punctuation">;</span></span>
<span class="line">    <span class="token comment">// 如果只在右子树中找到 p 或 q，返回右子树的结果</span></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span>right<span class="token punctuation">)</span> <span class="token keyword">return</span> right<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token comment">// 如果左右子树都没有找到 p 或 q，返回 null</span></span>
<span class="line">    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">  <span class="token keyword">return</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details>`,15))])}const v=e(d,[["render",u],["__file","236.html.vue"]]),b=JSON.parse('{"path":"/blogs/algorithm/leetcode/236.html","title":"LeetCode 「中等」236.二叉树的最近公共祖先","lang":"zh-CN","frontmatter":{"title":"LeetCode 「中等」236.二叉树的最近公共祖先","date":"2025-3-6","editLink":false,"tags":["LeetCode"],"categories":["算法"]},"headers":[{"level":2,"title":"题目描述","slug":"题目描述","link":"#题目描述","children":[]},{"level":2,"title":"解答","slug":"解答","link":"#解答","children":[{"level":3,"title":"DFS（深度优先搜索）","slug":"dfs-深度优先搜索","link":"#dfs-深度优先搜索","children":[]}]}],"git":{"createdTime":1741262459000,"updatedTime":1741335958000,"contributors":[{"name":"sanki","email":"sanqi_3737@163.com","commits":3}]},"filePathRelative":"blogs/algorithm/leetcode/236.md"}');export{v as comp,b as data};
